# -*- coding: UTF-8 -*-
#
# generated by wxGlade 1.0.4 on Thu Aug 15 17:13:58 2024
#

import wx
# begin wxGlade: dependencies
# end wxGlade

from tools import scale_bitmap

# begin wxGlade: extracode
from ShowMessage import *
from TextCheckboxSelect import *
# end wxGlade


class EditNode(wx.Dialog):
    # The 'config' variable points to a base of a table defined by 'schema', 'headers' and 'data' entries.
    def __init__(self, parent=None, config=None, edit_fields=[], schema=None, headers=None, data=None, *args, **kwds):
        self.config = config   # Entire config reference
        self.data = data       # Data for node being edited
        self.schema = schema   # Schema for node being edited
        self.headers = headers # Headers for node being edited
        self.edit_fields = edit_fields

        # print("EditNode: config %s" % config)
        # print("          edit_fields %s" % edit_fields)
        # print("          schema %s" % schema)
        # print("          headers %s" % headers)
        # print("          data %s" % data)

        self.data_changed = False

        kwds["parent"] = parent

        # begin wxGlade: EditNode.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER
        wx.Dialog.__init__(self, *args, **kwds)

        mainSizer = wx.FlexGridSizer(2, 1, 0, 0)

        self.itemSizer = wx.FlexGridSizer(0, 2, 5, 5)
        mainSizer.Add(self.itemSizer, 1, wx.ALL | wx.EXPAND, 5)

        buttonSizer = wx.FlexGridSizer(1, 3, 0, 0)
        mainSizer.Add(buttonSizer, 0, wx.ALIGN_CENTER | wx.ALL, 5)

        # Generate edit items
        rows=0
        # print("data is %s" % self.data)
        for field in self.edit_fields:
            schema = self.schema[field]
            description = self.headers[field]
            static_text, control = self.create_edit_entry(schema, description, field)
            if control is not None:
                rows = rows + 1
                # print("EditNode: filling row %d with field '%s' description '%s' schema '%s'" % (rows, field, description, schema))
                self.itemSizer.Add(static_text, 0, wx.ALIGN_CENTER_VERTICAL, 0)
                self.itemSizer.Add(control, 0, wx.ALIGN_CENTER_VERTICAL | wx.EXPAND, 0)

        self.itemSizer.SetRows(rows)
        self.Fit()
        # print("itemSizer has %d rows and %d cols" % (self.itemSizer.GetRows(), self.itemSizer.GetCols()))

        # End of generated edit items
        self.buttonOk = wx.Button(self, wx.ID_OK, _("OK"))
        self.buttonOk.SetDefault()
        buttonSizer.Add(self.buttonOk, 0, 0, 0)

        self.buttonCancel = wx.Button(self, wx.ID_CANCEL, _("Cancel"))
        buttonSizer.Add(self.buttonCancel, 0, 0, 0)

        self.deleteButton = wx.Button(self, wx.ID_DELETE, _("Delete"))
        buttonSizer.Add(self.deleteButton, 0, 0, 0)

        self.itemSizer.AddGrowableCol(1)

        mainSizer.AddGrowableRow(0)
        mainSizer.AddGrowableCol(0)
        self.SetSizer(mainSizer)
        mainSizer.Fit(self)

        self.Layout()
        #self.Maximize()
        self.Fit()
        self.Layout()
        self.SetTitle(self.data['name'])

        self.Bind(wx.EVT_BUTTON, self.OnOkButton, self.buttonOk)
        self.Bind(wx.EVT_BUTTON, self.OnCancelButton, self.buttonCancel)
        self.Bind(wx.EVT_BUTTON, self.OnDeleteButton, self.deleteButton)
        # end wxGlade

    # Create and return the static text and edit field as a tuple
    # Options for schema are:
    # "<unique-node>",                                  name is a unique node name (not already defined)
    # "<zero-or-more-node>"                             a list of zero or more nodes
    # "<one-or-more-node>"                              a list of one or more nodes
    # "<one-of-node>"                                   a list of one or more nodes
    # "<str>",                                          any string
    # "[ '<one-of>' 'item', 'item', 'item' ]            a choice of a single item
    # "[ '<zero-or-more>' 'item', 'item', 'item' ]      a choice of zero or more items
    # "[ '<one-or-more>' 'item', 'item', 'item' ]       a choice of one or more items
    # "<bool>"                                          a selector of Yes or No with Yes being True
    # "<icon>"                                          an icon file
    #
    # Returns a tuple:
    #    <static string with field label>, <control for editing results>
    #
    def create_edit_entry(self, schema, description, name):
        # print("create_edit_entry: description %s" % (description))
        # print("                   schema %s" % (schema))
        # print("                   name %s" % name)
        # print("                   config %s" % (self.config))
        control = None
        static_text = None

        data = self.data[name]

        # print("create_edit_entry: schema '%s' description '%s' name '%s' data '%s'" % (schema, description, name, self.data[name]))
        if schema == "<unique-node>":
            # Create a TextCtrl with an editing function to check for a unique node name
            control = wx.TextCtrl(self, wx.ID_ANY, self.data[name], name=name)
            data = self.data[name]

            # Create a list of current node names but remove the current node being edited from the list
            list_of_nodes = [ node['name'] for node in self.config['data']]
            if self.data['name'] in list_of_nodes:
                list_of_nodes.remove(self.data['name'])

            # print("Removed %s from node list: %s" % (data, list_of_nodes))
            control.Bind(wx.EVT_KILL_FOCUS, lambda event: self.OnCheckUniqueNodeName(event, invalid_names=list_of_nodes))

        elif schema == "<zero-or-more-nodes>":
            control = wx.TextCtrl(self, wx.ID_ANY, ", ".join(data), name=name)
            control.Bind(wx.EVT_LEFT_DOWN, lambda event: self.OnCheckboxMultiple(event, choices=[node['name'] for node in self.config['data']], choose="zero-or-more", title="Zero or more nodes"))

        elif schema == "<one-or-more-nodes>":
            control = wx.TextCtrl(self, wx.ID_ANY, ", ".join(data), name=name)
            control.Bind(wx.EVT_LEFT_DOWN, lambda event: self.OnCheckboxMultiple(event, choices=[node['name'] for node in self.config['data']], choose="one-or-more", title="One or more nodes"))

        elif schema == "<one-of-node>":
            control = wx.TextCtrl(self, wx.ID_ANY, data if data is not None else "" , name=name)
            control.Bind(wx.EVT_LEFT_DOWN, lambda event: self.OnCheckboxOneOf(event, choices=[node['name'] for node in self.config['data']], title="Chose one node"))

        elif schema == "<str>":
            control = wx.TextCtrl(self, wx.ID_ANY, str(self.data[name]), name=name)
            control.Bind(wx.EVT_SET_FOCUS, self.OnCheckFocusChange)
            control.Bind(wx.EVT_KILL_FOCUS, self.OnCheckFocusChange)

        elif schema == "<bool>":
            # Create a one-of for Yes/No and replace value with boolean
            control = wx.TextCtrl(self, wx.ID_ANY, "Yes" if data else "No", name=name)
            control.Bind(wx.EVT_LEFT_DOWN, lambda event: self.OnCheckboxBoolean(event, choices=["Yes", "No"]))

        elif type(schema) == list and len(schema) > 1:
            # A list of items
            if schema[0] == "<one-of>":
                 control = wx.TextCtrl(self, wx.ID_ANY, data if data is not None else "" , name=name)
                 control.Bind(wx.EVT_LEFT_DOWN, lambda event: self.OnCheckboxOneOf(event, choices=schema[1:], title="Choose one"))

            elif schema[0] == "<zero-or-more>":
                control = wx.TextCtrl(self, wx.ID_ANY, ", ".join(data) if type(data) is list else "", name=name)
                control.Bind(wx.EVT_LEFT_DOWN, lambda event: self.OnCheckboxMultiple(event, choices=schema[1:], choose="zero-or-more", title="Choose any of these"))

            elif schema[0] == "<one-or-more>":
                control = wx.TextCtrl(self, wx.ID_ANY, ", ".join(data) if type(data) is list else "", name=name)
                control.Bind(wx.EVT_LEFT_DOWN, lambda event: self.OnCheckboxMultiple(event, choices=schema[1:], choose="one-or-more", title="One or more"))
        elif schema == "<icon>":
            # Try to load the bitmap from the data string
            bitmap = wx.Bitmap()
            control = wx.BitmapButton(self, size=wx.Size(50, 50), name=name)

            if type(data) is str and bitmap.LoadFile(data):
                print("bitmap size is %s control is %s" % (bitmap.GetSize(), control.GetSize()))
                control.SetBitmap(scale_bitmap(bitmap, control.GetSize()))

            control.Bind(wx.EVT_BUTTON, self.OnEditIconButton)

        if control is None:
            # dlg = ShowMessage("Weird error")
            # dlg.ShowModal()
            pass
        else:
            # Create the static text
            static_text = wx.StaticText(self, label=description + ":")
            
        return static_text, control


    def OnTextEnter(self, event):  # wxGlade: EditNode.<event_handler>
        print("Event handler 'OnTextEnter' not implemented!")
        event.Skip()

    def OnCheckUniqueNodeName(self, event, invalid_names):
        item = event.GetEventObject()
        # print("OnCheckUniqueNodeName fired: %s" % invalid_names)
        newname = item.GetValue()
        if newname in invalid_names:
            msg = ShowMessage("%s is already used." % newname)
            msg.ShowModal()
            item.SetFocus()
            item.SetValue("")
        else:
            # Capture this info to the data table
            self.data[item.GetName()] = item.GetValue()
            self.data_changed = True
            event.Skip()

    # Bring up a checkbox dialog that allows any or none selection
    def OnCheckboxMultiple(self, event, choices, choose, title):
        item = event.GetEventObject()
        selected = self.data[item.GetName()]
        if selected is None:
            selected = []
        # print("Event handler: OnCheckboxMultiple")
        dlg = TextCheckboxSelect(self, choose=choose, choices=choices, selected=selected, title=title)
        if dlg.ShowModal() == wx.ID_OK:
            # Put the seletions back into the object
            items = dlg.GetSelectedItems()
            if items != self.data[item.GetName()]:
                # Put data back into config structure
                # print("data before update: %s" % str(self.data))
                self.data[item.GetName()] = items
                # print("data after update: %s" % str(self.data))
                # Set the displayed value of the item
                item.SetValue(", ".join(items))
                self.data_changed = True
        event.Skip()

    # Bring up a checkbox dialog that forces a single selection (i.e. deselects other selections automatically)
    def OnCheckboxOneOf(self, event, choices, title="Choose one node"):
        item = event.GetEventObject()

        # print("OnCheckboxOneOf: item is %s" % item.GetName())

        selected = self.data[item.GetName()]
        if selected is None:
            selected = []
        else:
            selected = [ selected ]

        # Open the dialog
        dlg = TextCheckboxSelect(self, choose="one-of", choices=choices, selected=selected, title=title)

        if dlg.ShowModal() == wx.ID_OK:
            items = dlg.GetSelectedItems()
            self.data[item.GetName()] = items[0]
            # Set the displayed value of the item
            item.SetValue(items[0])
            self.data_changed = True

    # Bring up a checkbox for a boolean value
    def OnCheckboxBoolean(self, event, choices = [ "Yes", "No" ]):
        item = event.GetEventObject()

        selected = choices[0] if self.data[item.GetName()] else choices[1]

        # print("OnCheckboxBoolean: choices is %s selected is %s" % (choices, selected))

        # Open the dialog
        dlg = TextCheckboxSelect(self, choose="one-of", choices=choices, selected=[selected], title="Yes or No")

        if dlg.ShowModal() == wx.ID_OK:
            items = dlg.GetSelectedItems()
            self.data[item.GetName()] = items[0] == choices[0]
            # Set the displayed value of the item
            item.SetValue(items[0])
            self.data_changed = True

    def OnEditIconButton(self, event):
        item = event.GetEventObject()

        # Ask user for new icon file
        with wx.FileDialog(self, "Select icon", wildcard="Image Files(*.bmp;*.gif;*.png;*.svg)|*.bmp;*.gif;*.png;*.svg",
                       style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) as fileDialog:

            if fileDialog.ShowModal() == wx.ID_OK:
                pathname = fileDialog.GetPath()
                print("OnEditIconButton: pathname %s" % pathname)
                try:
                    bitmap = wx.Bitmap()
                    if bitmap.LoadFile(pathname):
                        print("OnEditIconButton: bitmap size %s" % str(bitmap.GetSize()))
                        item.SetBitmap(scale_bitmap(bitmap, item.GetSize()))
                        self.data[item.GetName()] = pathname
                        self.data_changed = True
                    else:
                        print("OnEditIconButton: cannot load file")

                except Exception as e:
                    print("OnEditIconButton exception %s" % str(e))


    # Process OK and put the data back into the configuration table entry identified by 'name'
    def OnOkButton(self, event):  # wxGlade: EditNode.<event_handler>
        self.EndModal(wx.ID_OK)
        event.Skip()

    def OnCancelButton(self, event):  # wxGlade: EditNode.<event_handler>
        self.itemSizer.Clear(True)
        self.EndModal(wx.ID_CANCEL)
        event.Skip()

    def GetResults(self):
        return self.data

    def IsDataChanged(self):
        return self.data_changed

    def OnDeleteButton(self, event):  # wxGlade: EditNode.<event_handler>
        dlg = ShowMessage("Delete this entry?", "Are you sure?", buttons={"Yes": wx.ID_OK, "No": wx.ID_CANCEL})
        if dlg.ShowModal() == wx.ID_OK:
            self.EndModal(wx.ID_DELETE)
        event.Skip()

    def OnCheckFocusChange(self, event):
        event.Skip()

# end of class EditNode

