# -*- coding: UTF-8 -*-
#
# generated by wxGlade 1.0.4 on Thu Aug 15 10:46:33 2024
#

import wx
# begin wxGlade: dependencies
# end wxGlade

from ShowMessage import *

# begin wxGlade: extracode
from wx.lib.mixins import listctrl
import wx.lib.agw.ultimatelistctrl as ULC
import sys
from copy import deepcopy
class MyListCtrl(ULC.UltimateListCtrl):
    def __init__(self, parent, ID, pos=wx.DefaultPosition, size=wx.DefaultSize, style=0):
        agwStyle=wx.LC_REPORT|ULC.ULC_USER_ROW_HEIGHT|ULC.ULC_SINGLE_SEL|ULC.ULC_BORDER_SELECT|ULC.ULC_AUTO_TOGGLE_CHILD|ULC.ULC_HRULES|ULC.ULC_VRULES
        super(MyListCtrl, self).__init__(id=ID, parent=parent, size=size, style=style, agwStyle=agwStyle)

    def AppendColumn(self, header):
        self.InsertColumn(self.GetColumnCount(), header, format=ULC.ULC_FORMAT_LEFT)

    def AppendRow(self, datalist):
        # print("Append: %s" % datalist)
        row = self.InsertStringItem(sys.maxsize, datalist[0])
        for column in range(1, len(datalist)):
            field = datalist[column]
            self.SetColumnData(row, column, datalist[column])

    def SetColumnData(self, row, column, value):
        if type(value) is list:
            value = ", ".join(value)
        elif type(value) is bool:
            value = "Yes" if value else "No"
        elif value is None:
            value = ""
        else:
            value = "%s" % value

        self.SetStringItem(row, column, value)

    def UpdateColumnWidths(self):
        for column in range(self.GetColumnCount()):
            # Set column width to largest of header width and data width
            self.SetColumnWidth(column, width=wx.LIST_AUTOSIZE)
            datawidth = self.GetColumnWidth(column)
            self.SetColumnWidth(column, width=wx.LIST_AUTOSIZE_USEHEADER)
            hdrwidth = self.GetColumnWidth(column)
            if hdrwidth < datawidth:
                self.SetColumnWidth(column, datawidth)
# end wxGlade


#
# data is the base of the config tree of data to be selected as a table
# table_fields is the fields within each data element that will be displayed in the list
# edit_fields is passed to the editEntry dialog to define the total fields for editing
# schema is the schema definition for the table entry
# headers is the display-form of the field name (e.g. field='name' header='Node'
# editEntry is an optional dialog used to edit a table entry
#
class EditTable(wx.Dialog):
    def __init__(self, parent=None, title="Edit Table", config=[], table_fields=None, edit_fields=None, schema=None, headers=None, editEntry=None, *args, **kwds):
        self.parent = parent
        self.config = config
        self.editEntry = editEntry
        self.data_changed = False
        self.data = deepcopy(config["data"])

        self.table_fields = table_fields if table_fields is not None else config["table_fields"]
        self.edit_fields = edit_fields if edit_fields is not None else config["edit_fields"]
        # self.headers = headers if headers is not None else [ config["headers"][node] for node in self.edit_fields ]
        self.headers = headers if headers is not None else config['headers']
        self.schema = schema if schema is not None else config["schema"]

        kwds['parent'] = parent

        # begin wxGlade: EditTable.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER
        wx.Dialog.__init__(self, *args, **kwds)

        mainSizer = wx.FlexGridSizer(2, 1, 0, 0)

        self.itemList = MyListCtrl(self, wx.ID_ANY, style=wx.LC_LIST)
        # Popluate the header
        for header in self.headers:
            self.itemList.AppendColumn(header)

        # Populate the rows
        for row in self.data:
            self.itemList.AppendRow([row[field] for field in self.table_fields])

        # Force autosize columns
        self.itemList.UpdateColumnWidths()
        mainSizer.Add(self.itemList, 1, wx.ALL | wx.EXPAND, 0)

        buttonSizer = wx.FlexGridSizer(1, 3, 0, 0)
        mainSizer.Add(buttonSizer, 0, wx.ALIGN_CENTER | wx.ALL, 5)

        self.buttonOk = wx.Button(self, wx.ID_OK, "")
        buttonSizer.Add(self.buttonOk, 0, 0, 0)

        self.buttonCancel = wx.Button(self, wx.ID_CANCEL, "")
        buttonSizer.Add(self.buttonCancel, 0, 0, 0)

        self.buttonNew = wx.Button(self, wx.ID_ADD, "")
        buttonSizer.Add(self.buttonNew, 0, 0, 0)

        mainSizer.AddGrowableRow(0)
        mainSizer.AddGrowableCol(0)
        self.SetSizer(mainSizer)
        mainSizer.Fit(self)

        self.SetAffirmativeId(self.buttonOk.GetId())
        self.SetEscapeId(self.buttonCancel.GetId())

        self.Layout()
        self.Maximize()
        self.Fit()
        self.Layout()
        self.SetTitle(title)

        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnItemSelected, self.itemList)
        self.Bind(wx.EVT_BUTTON, self.OnAddButton, self.buttonNew)
        # end wxGlade

    # On selected item, open editEntry dialog
    def OnItemSelected(self, event):  # wxGlade: EditTable.<event_handler>
        item = event.GetEventObject()
        row = event.GetIndex()
        itemdata = deepcopy(self.data[row])

        # print("OnItemSelected: row %d" % row)
        # print("                schema %s" % self.schema)
        # print("                edit_fields %s" % self.edit_fields)
        # print("                headers %s" % self.headers)
        # print("                data %s" % itemdata)

        if self.editEntry is not None:
            # Must pass original headers 'dict' to get mappings
            dlg = self.editEntry(self, config=self.config, schema=self.schema, edit_fields=self.edit_fields, headers=self.headers, data=itemdata)
            results = dlg.ShowModal()
            if results == wx.ID_OK:
                # Change the parent data element with the results
                print("Results: changed %s row %s data %s" % (dlg.IsDataChanged(), row, dlg.GetResults()))
                if dlg.IsDataChanged():
                    results = dlg.GetResults()
                    if len(results['name']) != 0:
                        # Refill this row's data
                        # self.itemList.SetColumnData(row, 
                        for column in range(len(self.table_fields)):
                            self.itemList.SetColumnData(row, column, results[self.table_fields[column]])
                        self.itemList.UpdateColumnWidths()
                        self.data[row] = results
                        self.data_changed = True
            elif results == wx.ID_DELETE:
                # Delete this entry
                # print("Delete request on row %d" % row)
                del(self.data[row])
                self.RedrawItemList()
                self.data_changed = True
            else:
                print("editEntry failed")
        else:
            print("no editEntry")
                
        event.Skip()

    # Add an item into the table
    def OnAddButton(self, event):  # wxGlade: EditTable.<event_handler>
        if self.editEntry is not None:
            # Must pass original headers 'dict' to get mappings
            itemdata = deepcopy(self.config['default'])
            itemdata['name'] = ""
            # Temporarily place into config table
            row = len(self.config['data'])
            # self.config['data'].append(itemdata)
            dlg = self.editEntry(self, config=self.config, schema=self.schema, edit_fields=self.edit_fields, headers=self.config["headers"], data=itemdata)
            if dlg.ShowModal() == wx.ID_OK:
                # Change the parent data element with the results
                # print("Results: changed %s row %s data %s" % (dlg.IsDataChanged(), row, dlg.GetResults()))
                if dlg.IsDataChanged():
                    self.data.append(dlg.GetResults())
                    self.RedrawItemList()
                    self.data_changed = True
            else:
                # Delete the data row
                del(self.config['data'][row])
                print("editEntry failed")
        event.Skip()
    
    def RedrawItemList(self):
        self.itemList.ClearAll()

        # Popluate the header
        for header in self.headers:
            self.itemList.AppendColumn(header)

        # Populate the rows
        for row in self.data:
            self.itemList.AppendRow([row[field] for field in self.table_fields])

        self.itemList.UpdateColumnWidths()

    def IsDataChanged(self):
        return self.data_changed

    def GetResults(self):
        return self.data

# end of class EditTable
